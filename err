In file included from srcs/mainft.cpp:3:
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::trees_type* ft::map<Key, T, Compare, Alloc>::get_root()’:
includes/map.h:80:12: error: ‘Avl’ was not declared in this scope
   80 |    return (Avl.get_root());
      |            ^~~
includes/map.h: In member function ‘bool ft::map<Key, T, Compare, Alloc>::empty() const’:
includes/map.h:85:8: error: ‘Avl’ was not declared in this scope
   85 |    if (Avl.get_root() == NULL)
      |        ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::size_type ft::map<Key, T, Compare, Alloc>::size() const’:
includes/map.h:92:11: error: ‘Avl’ was not declared in this scope
   92 |    return Avl.size();
      |           ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::size_type ft::map<Key, T, Compare, Alloc>::max_size() const’:
includes/map.h:97:11: error: ‘Avl’ was not declared in this scope
   97 |    return Avl.max_size();
      |           ^~~
includes/map.h: In member function ‘void ft::map<Key, T, Compare, Alloc>::insert(InputIterator, InputIterator, typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type*)’:
includes/map.h:107:5: error: ‘Avl’ was not declared in this scope
  107 |     Avl.insert(ft::make_pair<key_type, mapped_type>(tmp->first, tmp->second));
      |     ^~~
includes/map.h: In member function ‘ft::pair<ft::bidirectional_iterator<ft::pair<T1, T2> >, bool> ft::map<Key, T, Compare, Alloc>::insert(const value_type&)’:
includes/map.h:114:12: error: ‘Avl’ was not declared in this scope
  114 |    return (Avl.insert(val));
      |            ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::size_type ft::map<Key, T, Compare, Alloc>::erase(const key_type&)’:
includes/map.h:126:12: error: ‘Avl’ was not declared in this scope
  126 |    return (Avl.erase(val));
      |            ^~~
includes/map.h: In member function ‘void ft::map<Key, T, Compare, Alloc>::erase(ft::map<Key, T, Compare, Alloc>::iterator)’:
includes/map.h:131:4: error: ‘Avl’ was not declared in this scope
  131 |    Avl.erase(position->first);
      |    ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::find(const key_type&)’:
includes/map.h:163:12: error: ‘Avl’ was not declared in this scope
  163 |    return (Avl.found_key(k));
      |            ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::const_iterator ft::map<Key, T, Compare, Alloc>::find(const key_type&) const’:
includes/map.h:168:18: error: ‘Avl’ was not declared in this scope
  168 |    iterator it = Avl.found_key(k);
      |                  ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::size_type ft::map<Key, T, Compare, Alloc>::count(const key_type&) const’:
includes/map.h:257:12: error: ‘Avl’ was not declared in this scope
  257 |    return (Avl.is_key_here(k));
      |            ^~~
includes/map.h: In member function ‘void ft::map<Key, T, Compare, Alloc>::swap(ft::map<Key, T, Compare, Alloc>&)’:
includes/map.h:262:4: error: ‘Avl’ was not declared in this scope
  262 |    Avl.swap(other.Avl);
      |    ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::begin()’:
includes/map.h:272:12: error: ‘Avl’ was not declared in this scope
  272 |    return (Avl.begin());
      |            ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::const_iterator ft::map<Key, T, Compare, Alloc>::begin() const’:
includes/map.h:277:27: error: ‘Avl’ was not declared in this scope
  277 |    return (const_iterator(Avl.begin()));
      |                           ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::end()’:
includes/map.h:282:12: error: ‘Avl’ was not declared in this scope
  282 |    return (Avl.end());
      |            ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::const_iterator ft::map<Key, T, Compare, Alloc>::end() const’:
includes/map.h:287:27: error: ‘Avl’ was not declared in this scope
  287 |    return (const_iterator(Avl.end()));
      |                           ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::reverse_iterator ft::map<Key, T, Compare, Alloc>::rbegin()’:
includes/map.h:292:16: error: ‘Avl’ was not declared in this scope
  292 |    iterator it(Avl.end());
      |                ^~~
includes/map.h: In member function ‘ft::map<Key, T, Compare, Alloc>::reverse_iterator ft::map<Key, T, Compare, Alloc>::rend()’:
includes/map.h:299:16: error: ‘Avl’ was not declared in this scope
  299 |    iterator it(Avl.begin());
      |                ^~~
srcs/mainft.cpp: In function ‘int test_zero()’:
srcs/mainft.cpp:133:30: error: conversion from ‘ft::map<char, foo<float> >::iterator’ {aka ‘ft::bidirectional_iterator<ft::pair<char, foo<float> > >’} to non-scalar type ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} requested
  133 |  for (const_it it1 = mp.begin(); it1 != mp.end(); ++it1)
      |                      ~~~~~~~~^~
srcs/mainft.cpp:133:38: error: no match for ‘operator!=’ (operand types are ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} and ‘ft::map<char, foo<float> >::iterator’ {aka ‘ft::bidirectional_iterator<ft::pair<char, foo<float> > >’})
  133 |  for (const_it it1 = mp.begin(); it1 != mp.end(); ++it1)
      |                                  ~~~ ^~ ~~~~~~~~
      |                                  |            |
      |                                  |            ft::map<char, foo<float> >::iterator {aka ft::bidirectional_iterator<ft::pair<char, foo<float> > >}
      |                                  const_it {aka ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >}
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h:85:7: note: candidate: ‘bool ft::const_bidirectional_iterator<T>::operator!=(const ft::const_bidirectional_iterator<T>&) const [with T = ft::pair<char, foo<float> >]’
   85 |  bool const_bidirectional_iterator<T>::operator!=(const const_bidirectional_iterator &rhs) const
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
includes/const_bidirectional_iterator.h:85:87: note:   no known conversion for argument 1 from ‘ft::map<char, foo<float> >::iterator’ {aka ‘ft::bidirectional_iterator<ft::pair<char, foo<float> > >’} to ‘const ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >&’
   85 |  bool const_bidirectional_iterator<T>::operator!=(const const_bidirectional_iterator &rhs) const
      |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from includes/avl_tree.h:11,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/reverse_iterator.h:129:7: note: candidate: ‘template<class Iterator> bool ft::operator!=(const ft::reverse_iterator<Iterator>&, const ft::reverse_iterator<Iterator>&)’
  129 |  bool operator!=
      |       ^~~~~~~~
includes/reverse_iterator.h:129:7: note:   template argument deduction/substitution failed:
srcs/mainft.cpp:133:48: note:   ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} is not derived from ‘const ft::reverse_iterator<Iterator>’
  133 |  for (const_it it1 = mp.begin(); it1 != mp.end(); ++it1)
      |                                                ^
In file included from includes/Node.h:3,
                 from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/pair.h:54:7: note: candidate: ‘template<class T1, class T2> bool ft::operator!=(const ft::pair<T1, T2>&, const ft::pair<T1, T2>&)’
   54 |  bool operator!= (const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
      |       ^~~~~~~~
includes/pair.h:54:7: note:   template argument deduction/substitution failed:
srcs/mainft.cpp:133:48: note:   ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} is not derived from ‘const ft::pair<T1, T2>’
  133 |  for (const_it it1 = mp.begin(); it1 != mp.end(); ++it1)
      |                                                ^
In file included from srcs/mainft.cpp:3:
includes/map.h:339:7: note: candidate: ‘template<class Key, class T, class Compare, class Alloc> bool ft::operator!=(const ft::map<Key, T, Compare, Alloc>&, const ft::map<Key, T, Compare, Alloc>&)’
  339 |  bool operator!=(const map<Key,T,Compare,Alloc>& lhs, const map<Key,T,Compare,Alloc>& rhs)
      |       ^~~~~~~~
includes/map.h:339:7: note:   template argument deduction/substitution failed:
srcs/mainft.cpp:133:48: note:   ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} is not derived from ‘const ft::map<Key, T, Compare, Alloc>’
  133 |  for (const_it it1 = mp.begin(); it1 != mp.end(); ++it1)
      |                                                ^
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h:63:15: note: candidate: ‘bool ft::operator!=(const ft::bidirectional_iterator<ft::pair<char, foo<float> > >&, const ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >&)’
   63 |   friend bool operator!=(const bidirectional_iterator<T> &lhs, const const_bidirectional_iterator &rhs)
      |               ^~~~~~~~
includes/const_bidirectional_iterator.h:63:59: note:   no known conversion for argument 1 from ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} to ‘const ft::bidirectional_iterator<ft::pair<char, foo<float> > >&’
   63 |   friend bool operator!=(const bidirectional_iterator<T> &lhs, const const_bidirectional_iterator &rhs)
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
srcs/mainft.cpp:134:32: error: conversion from ‘ft::map<char, foo<float> >::iterator’ {aka ‘ft::bidirectional_iterator<ft::pair<char, foo<float> > >’} to non-scalar type ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} requested
  134 |   for (const_it iDEF = mp.begin(); iDEF != mp.end(); ++iDEF)
      |                        ~~~~~~~~^~
srcs/mainft.cpp:134:41: error: no match for ‘operator!=’ (operand types are ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} and ‘ft::map<char, foo<float> >::iterator’ {aka ‘ft::bidirectional_iterator<ft::pair<char, foo<float> > >’})
  134 |   for (const_it iDEF = mp.begin(); iDEF != mp.end(); ++iDEF)
      |                                    ~~~~ ^~ ~~~~~~~~
      |                                    |             |
      |                                    |             ft::map<char, foo<float> >::iterator {aka ft::bidirectional_iterator<ft::pair<char, foo<float> > >}
      |                                    const_it {aka ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >}
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h:85:7: note: candidate: ‘bool ft::const_bidirectional_iterator<T>::operator!=(const ft::const_bidirectional_iterator<T>&) const [with T = ft::pair<char, foo<float> >]’
   85 |  bool const_bidirectional_iterator<T>::operator!=(const const_bidirectional_iterator &rhs) const
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
includes/const_bidirectional_iterator.h:85:87: note:   no known conversion for argument 1 from ‘ft::map<char, foo<float> >::iterator’ {aka ‘ft::bidirectional_iterator<ft::pair<char, foo<float> > >’} to ‘const ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >&’
   85 |  bool const_bidirectional_iterator<T>::operator!=(const const_bidirectional_iterator &rhs) const
      |                                                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
In file included from includes/avl_tree.h:11,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/reverse_iterator.h:129:7: note: candidate: ‘template<class Iterator> bool ft::operator!=(const ft::reverse_iterator<Iterator>&, const ft::reverse_iterator<Iterator>&)’
  129 |  bool operator!=
      |       ^~~~~~~~
includes/reverse_iterator.h:129:7: note:   template argument deduction/substitution failed:
srcs/mainft.cpp:134:51: note:   ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} is not derived from ‘const ft::reverse_iterator<Iterator>’
  134 |   for (const_it iDEF = mp.begin(); iDEF != mp.end(); ++iDEF)
      |                                                   ^
In file included from includes/Node.h:3,
                 from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/pair.h:54:7: note: candidate: ‘template<class T1, class T2> bool ft::operator!=(const ft::pair<T1, T2>&, const ft::pair<T1, T2>&)’
   54 |  bool operator!= (const pair<T1,T2>& lhs, const pair<T1,T2>& rhs)
      |       ^~~~~~~~
includes/pair.h:54:7: note:   template argument deduction/substitution failed:
srcs/mainft.cpp:134:51: note:   ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} is not derived from ‘const ft::pair<T1, T2>’
  134 |   for (const_it iDEF = mp.begin(); iDEF != mp.end(); ++iDEF)
      |                                                   ^
In file included from srcs/mainft.cpp:3:
includes/map.h:339:7: note: candidate: ‘template<class Key, class T, class Compare, class Alloc> bool ft::operator!=(const ft::map<Key, T, Compare, Alloc>&, const ft::map<Key, T, Compare, Alloc>&)’
  339 |  bool operator!=(const map<Key,T,Compare,Alloc>& lhs, const map<Key,T,Compare,Alloc>& rhs)
      |       ^~~~~~~~
includes/map.h:339:7: note:   template argument deduction/substitution failed:
srcs/mainft.cpp:134:51: note:   ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} is not derived from ‘const ft::map<Key, T, Compare, Alloc>’
  134 |   for (const_it iDEF = mp.begin(); iDEF != mp.end(); ++iDEF)
      |                                                   ^
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h:63:15: note: candidate: ‘bool ft::operator!=(const ft::bidirectional_iterator<ft::pair<char, foo<float> > >&, const ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >&)’
   63 |   friend bool operator!=(const bidirectional_iterator<T> &lhs, const const_bidirectional_iterator &rhs)
      |               ^~~~~~~~
includes/const_bidirectional_iterator.h:63:59: note:   no known conversion for argument 1 from ‘const_it’ {aka ‘ft::const_bidirectional_iterator<ft::pair<char, foo<float> > >’} to ‘const ft::bidirectional_iterator<ft::pair<char, foo<float> > >&’
   63 |   friend bool operator!=(const bidirectional_iterator<T> &lhs, const const_bidirectional_iterator &rhs)
      |                          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~
includes/const_bidirectional_iterator.h: In instantiation of ‘T* ft::const_bidirectional_iterator<T>::operator->() const [with T = ft::pair<char, foo<float> >; ft::const_bidirectional_iterator<T>::pointer = ft::pair<char, foo<float> >*]’:
srcs/mainft.cpp:117:28:   required from here
includes/const_bidirectional_iterator.h:100:17: error: ‘class ft::Node<ft::pair<char, foo<float> > >’ has no member named ‘value’; did you mean ‘_value’?
  100 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/const_bidirectional_iterator.h: In instantiation of ‘T& ft::const_bidirectional_iterator<T>::operator*() const [with T = ft::pair<char, foo<float> >; ft::const_bidirectional_iterator<T>::reference = ft::pair<char, foo<float> >&]’:
srcs/mainft.cpp:118:28:   required from here
includes/const_bidirectional_iterator.h:94:16: error: ‘class ft::Node<ft::pair<char, foo<float> > >’ has no member named ‘value’; did you mean ‘_value’?
   94 |   return (_it->value);
      |          ~~~~~~^~~~~~
      |          _value
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>& ft::const_bidirectional_iterator<T>::operator++() [with T = ft::pair<char, foo<float> >]’:
srcs/mainft.cpp:133:53:   required from here
includes/const_bidirectional_iterator.h:106:7: error: no matching function for call to ‘ft::Node<ft::pair<char, foo<float> > >::next()’
  106 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<char, foo<float> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<char, int>]’:
srcs/mainft.cpp:203:5:   required from here
includes/bidirectional_iterator.h:109:7: error: no matching function for call to ‘ft::Node<ft::pair<char, int> >::next()’
  109 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<char, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘T* ft::bidirectional_iterator<T>::operator->() const [with T = ft::pair<char, int>; ft::bidirectional_iterator<T>::pointer = ft::pair<char, int>*]’:
srcs/mainft.cpp:203:7:   required from here
includes/bidirectional_iterator.h:95:17: error: ‘class ft::Node<ft::pair<char, int> >’ has no member named ‘value’; did you mean ‘_value’?
   95 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>& ft::bidirectional_iterator<T>::operator++() [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’:
srcs/mainft.cpp:248:26:   required from here
includes/bidirectional_iterator.h:101:7: error: no matching function for call to ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::next()’
  101 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>::bidirectional_iterator(const ft::bidirectional_iterator<T>&) [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’:
srcs/mainft.cpp:248:27:   required from here
includes/bidirectional_iterator.h:37:9: error: lvalue required as left operand of assignment
   37 |    this = copy;
      |    ~~~~~^~~~~~
includes/bidirectional_iterator.h: In instantiation of ‘T* ft::bidirectional_iterator<T>::operator->() const [with T = ft::pair<int, std::__cxx11::basic_string<char> >; ft::bidirectional_iterator<T>::pointer = ft::pair<int, std::__cxx11::basic_string<char> >*]’:
srcs/mainft.cpp:277:25:   required from here
includes/bidirectional_iterator.h:95:17: error: ‘class ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ has no member named ‘value’; did you mean ‘_value’?
   95 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>::bidirectional_iterator(const ft::bidirectional_iterator<T>&) [with T = ft::pair<int, int>]’:
srcs/mainft.cpp:298:56:   required from here
includes/bidirectional_iterator.h:37:9: error: lvalue required as left operand of assignment
   37 |    this = copy;
      |    ~~~~~^~~~~~
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>& ft::bidirectional_iterator<T>::operator++() [with T = ft::pair<int, int>]’:
srcs/mainft.cpp:302:31:   required from here
includes/bidirectional_iterator.h:101:7: error: no matching function for call to ‘ft::Node<ft::pair<int, int> >::next()’
  101 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘T* ft::bidirectional_iterator<T>::operator->() const [with T = ft::pair<int, int>; ft::bidirectional_iterator<T>::pointer = ft::pair<int, int>*]’:
srcs/mainft.cpp:303:5:   required from here
includes/bidirectional_iterator.h:95:17: error: ‘class ft::Node<ft::pair<int, int> >’ has no member named ‘value’; did you mean ‘_value’?
   95 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘T* ft::bidirectional_iterator<T>::operator->() const [with T = ft::pair<int, foo<int> >; ft::bidirectional_iterator<T>::pointer = ft::pair<int, foo<int> >*]’:
srcs/mainft.cpp:382:19:   required from here
includes/bidirectional_iterator.h:95:17: error: ‘class ft::Node<ft::pair<int, foo<int> > >’ has no member named ‘value’; did you mean ‘_value’?
   95 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>::bidirectional_iterator(const ft::bidirectional_iterator<T>&) [with T = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’:
srcs/mainft.cpp:423:30:   required from here
includes/bidirectional_iterator.h:37:9: error: lvalue required as left operand of assignment
   37 |    this = copy;
      |    ~~~~~^~~~~~
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::tree(const compare_type&, const allocator_type&) [with Pair = ft::pair<char, foo<float> >; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, foo<float> > > >; ft::tree<Pair, Compare, Alloc>::compare_type = std::less<char>; ft::tree<Pair, Compare, Alloc>::allocator_type = std::allocator<ft::Node<ft::pair<char, foo<float> > > >]’:
includes/map.h:57:131:   required from ‘ft::map<Key, T, Compare, Alloc>::map(const key_compare&, const allocator_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<char>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const char, foo<float> > >]’
srcs/mainft.cpp:125:7:   required from here
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<char, foo<float> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<char, foo<float> >; ft::Node<Pair>::value_type = ft::pair<char, foo<float> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<char, foo<float> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<char, foo<float> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<char, foo<float> > >::Node(const ft::Node<ft::pair<char, foo<float> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<char, foo<float> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<char, foo<float> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<char, foo<float> >; ft::Node<Pair>::value_type = ft::pair<char, foo<float> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<char, foo<float> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<char, foo<float> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<char, foo<float> > >::Node(const ft::Node<ft::pair<char, foo<float> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<char, foo<float> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:48:14: error: no match for ‘operator=’ (operand types are ‘ft::Node<ft::pair<char, foo<float> > >’ and ‘ft::tree<ft::pair<char, foo<float> >, std::less<char>, std::allocator<ft::Node<ft::pair<char, foo<float> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, foo<float> > >*’})
   48 |    _real_end = new_node(ft::pair<key_type, val_type>());
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<char, foo<float> > >& ft::Node<ft::pair<char, foo<float> > >::operator=(const ft::Node<ft::pair<char, foo<float> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘ft::tree<ft::pair<char, foo<float> >, std::less<char>, std::allocator<ft::Node<ft::pair<char, foo<float> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, foo<float> > >*’} to ‘const ft::Node<ft::pair<char, foo<float> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:50:4: error: base operand of ‘->’ has non-pointer type ‘ft::Node<ft::pair<char, foo<float> > >’
   50 |    _real_end->print = 0;
      |    ^~~~~~~~~
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::~tree() [with Pair = ft::pair<char, foo<float> >; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, foo<float> > > >]’:
includes/map.h:57:131:   required from ‘ft::map<Key, T, Compare, Alloc>::map(const key_compare&, const allocator_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<char>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const char, foo<float> > >]’
srcs/mainft.cpp:125:7:   required from here
includes/avl_tree.h:56:8: error: could not convert ‘((ft::tree<ft::pair<char, foo<float> >, std::less<char>, std::allocator<ft::Node<ft::pair<char, foo<float> > > > >*)this)->ft::tree<ft::pair<char, foo<float> >, std::less<char>, std::allocator<ft::Node<ft::pair<char, foo<float> > > > >::_root’ from ‘ft::Node<ft::pair<char, foo<float> > >’ to ‘bool’
   56 |    if (_root)
      |        ^~~~~
      |        |
      |        ft::Node<ft::pair<char, foo<float> > >
includes/avl_tree.h:57:15: error: cannot convert ‘ft::Node<ft::pair<char, foo<float> > >’ to ‘ft::Node<ft::pair<char, foo<float> > >*&’
   57 |     clear_all(_root);
      |               ^~~~~
      |               |
      |               ft::Node<ft::pair<char, foo<float> > >
includes/avl_tree.h:120:28: note:   initializing argument 1 of ‘void ft::tree<Pair, Compare, Alloc>::clear_all(ft::Node<T>*&) [with Pair = ft::pair<char, foo<float> >; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, foo<float> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<char, foo<float> > >*]’
  120 |   void clear_all(node_ptr &tmp)
      |                  ~~~~~~~~~~^~~
includes/avl_tree.h:58:26: error: cannot convert ‘ft::Node<ft::pair<char, foo<float> > >’ to ‘ft::tree<ft::pair<char, foo<float> >, std::less<char>, std::allocator<ft::Node<ft::pair<char, foo<float> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, foo<float> > >*’}
   58 |    _root = _destroy_node(_root);
      |                          ^~~~~
      |                          |
      |                          ft::Node<ft::pair<char, foo<float> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<char, foo<float> >; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, foo<float> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<char, foo<float> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
includes/avl_tree.h:59:18: error: cannot convert ‘ft::Node<ft::pair<char, foo<float> > >’ to ‘ft::tree<ft::pair<char, foo<float> >, std::less<char>, std::allocator<ft::Node<ft::pair<char, foo<float> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, foo<float> > >*’}
   59 |    _destroy_node(_real_end);
      |                  ^~~~~~~~~
      |                  |
      |                  ft::Node<ft::pair<char, foo<float> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<char, foo<float> >; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, foo<float> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<char, foo<float> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>::bidirectional_iterator(const ft::bidirectional_iterator<T>&) [with T = ft::pair<char, foo<float> >]’:
includes/map.h:319:13:   required from ‘ft::map<Key, T, Compare, Alloc>::mapped_type& ft::map<Key, T, Compare, Alloc>::operator[](const key_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::mapped_type = foo<float>; ft::map<Key, T, Compare, Alloc>::key_type = char]’
srcs/mainft.cpp:127:8:   required from here
includes/bidirectional_iterator.h:37:9: error: lvalue required as left operand of assignment
   37 |    this = copy;
      |    ~~~~~^~~~~~
includes/bidirectional_iterator.h: In instantiation of ‘bool ft::bidirectional_iterator<T>::operator==(const ft::bidirectional_iterator<T>&) const [with T = ft::pair<char, foo<float> >]’:
includes/map.h:320:10:   required from ‘ft::map<Key, T, Compare, Alloc>::mapped_type& ft::map<Key, T, Compare, Alloc>::operator[](const key_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::mapped_type = foo<float>; ft::map<Key, T, Compare, Alloc>::key_type = char]’
srcs/mainft.cpp:127:8:   required from here
includes/bidirectional_iterator.h:75:17: error: ‘class ft::Node<ft::pair<char, foo<float> > >’ has no member named ‘value’; did you mean ‘_value’?
   75 |   return (&_it->value == rhs.operator->());
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘T& ft::bidirectional_iterator<T>::operator*() const [with T = ft::pair<char, foo<float> >; ft::bidirectional_iterator<T>::reference = ft::pair<char, foo<float> >&]’:
includes/map.h:320:37:   required from ‘ft::map<Key, T, Compare, Alloc>::mapped_type& ft::map<Key, T, Compare, Alloc>::operator[](const key_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::mapped_type = foo<float>; ft::map<Key, T, Compare, Alloc>::key_type = char]’
srcs/mainft.cpp:127:8:   required from here
includes/bidirectional_iterator.h:89:16: error: ‘class ft::Node<ft::pair<char, foo<float> > >’ has no member named ‘value’; did you mean ‘_value’?
   89 |   return (_it->value);
      |          ~~~~~~^~~~~~
      |          _value
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>::const_bidirectional_iterator(const ft::const_bidirectional_iterator<T>&) [with T = ft::pair<char, foo<float> >]’:
srcs/mainft.cpp:80:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<char, foo<float> >]’
srcs/mainft.cpp:131:14:   required from here
includes/const_bidirectional_iterator.h:31:9: error: lvalue required as left operand of assignment
   31 |    this = copy;
      |    ~~~~~^~~~~~
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::tree(const compare_type&, const allocator_type&) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::compare_type = std::less<int>; ft::tree<Pair, Compare, Alloc>::allocator_type = std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const int, std::__cxx11::basic_string<char> > >; Key = int; T = std::__cxx11::basic_string<char>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:165:58:   required from here
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; ft::Node<Pair>::value_type = ft::pair<int, std::__cxx11::basic_string<char> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<int, std::__cxx11::basic_string<char> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::Node(const ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; ft::Node<Pair>::value_type = ft::pair<int, std::__cxx11::basic_string<char> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<int, std::__cxx11::basic_string<char> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::Node(const ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:48:14: error: no match for ‘operator=’ (operand types are ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ and ‘ft::tree<ft::pair<int, std::__cxx11::basic_string<char> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*’})
   48 |    _real_end = new_node(ft::pair<key_type, val_type>());
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >& ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::operator=(const ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘ft::tree<ft::pair<int, std::__cxx11::basic_string<char> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*’} to ‘const ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:50:4: error: base operand of ‘->’ has non-pointer type ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’
   50 |    _real_end->print = 0;
      |    ^~~~~~~~~
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::~tree() [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const int, std::__cxx11::basic_string<char> > >; Key = int; T = std::__cxx11::basic_string<char>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:165:58:   required from here
includes/avl_tree.h:56:8: error: could not convert ‘((ft::tree<ft::pair<int, std::__cxx11::basic_string<char> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > > >*)this)->ft::tree<ft::pair<int, std::__cxx11::basic_string<char> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > > >::_root’ from ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ to ‘bool’
   56 |    if (_root)
      |        ^~~~~
      |        |
      |        ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:57:15: error: cannot convert ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ to ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*&’
   57 |     clear_all(_root);
      |               ^~~~~
      |               |
      |               ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:120:28: note:   initializing argument 1 of ‘void ft::tree<Pair, Compare, Alloc>::clear_all(ft::Node<T>*&) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*]’
  120 |   void clear_all(node_ptr &tmp)
      |                  ~~~~~~~~~~^~~
includes/avl_tree.h:58:26: error: cannot convert ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ to ‘ft::tree<ft::pair<int, std::__cxx11::basic_string<char> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*’}
   58 |    _root = _destroy_node(_root);
      |                          ^~~~~
      |                          |
      |                          ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
includes/avl_tree.h:59:18: error: cannot convert ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ to ‘ft::tree<ft::pair<int, std::__cxx11::basic_string<char> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*’}
   59 |    _destroy_node(_real_end);
      |                  ^~~~~~~~~
      |                  |
      |                  ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>::const_bidirectional_iterator(const ft::const_bidirectional_iterator<T>&) [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’:
srcs/mainft.cpp:80:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, std::__cxx11::basic_string<char> >]’
srcs/mainft.cpp:168:14:   required from here
includes/const_bidirectional_iterator.h:31:9: error: lvalue required as left operand of assignment
   31 |    this = copy;
      |    ~~~~~^~~~~~
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>& ft::const_bidirectional_iterator<T>::operator++() [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’:
srcs/mainft.cpp:82:21:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, std::__cxx11::basic_string<char> >]’
srcs/mainft.cpp:168:14:   required from here
includes/const_bidirectional_iterator.h:106:7: error: no matching function for call to ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::next()’
  106 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::tree(const compare_type&, const allocator_type&) [with Pair = ft::pair<char, int>; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, int> > >; ft::tree<Pair, Compare, Alloc>::compare_type = std::less<char>; ft::tree<Pair, Compare, Alloc>::allocator_type = std::allocator<ft::Node<ft::pair<char, int> > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const char, int> >; Key = char; T = int; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, int> >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<char>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const char, int> >]’
srcs/mainft.cpp:190:57:   required from here
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<char, int> >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<char, int>; ft::Node<Pair>::value_type = ft::pair<char, int>]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<char, int>&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<char, int>]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<char, int> >::Node(const ft::Node<ft::pair<char, int> >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<char, int> >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<char, int> >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<char, int>; ft::Node<Pair>::value_type = ft::pair<char, int>]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<char, int>&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<char, int>]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<char, int> >::Node(const ft::Node<ft::pair<char, int> >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<char, int> >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:48:14: error: no match for ‘operator=’ (operand types are ‘ft::Node<ft::pair<char, int> >’ and ‘ft::tree<ft::pair<char, int>, std::less<char>, std::allocator<ft::Node<ft::pair<char, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, int> >*’})
   48 |    _real_end = new_node(ft::pair<key_type, val_type>());
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<char, int> >& ft::Node<ft::pair<char, int> >::operator=(const ft::Node<ft::pair<char, int> >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘ft::tree<ft::pair<char, int>, std::less<char>, std::allocator<ft::Node<ft::pair<char, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, int> >*’} to ‘const ft::Node<ft::pair<char, int> >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:50:4: error: base operand of ‘->’ has non-pointer type ‘ft::Node<ft::pair<char, int> >’
   50 |    _real_end->print = 0;
      |    ^~~~~~~~~
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::~tree() [with Pair = ft::pair<char, int>; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, int> > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const char, int> >; Key = char; T = int; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, int> >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<char>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const char, int> >]’
srcs/mainft.cpp:190:57:   required from here
includes/avl_tree.h:56:8: error: could not convert ‘((ft::tree<ft::pair<char, int>, std::less<char>, std::allocator<ft::Node<ft::pair<char, int> > > >*)this)->ft::tree<ft::pair<char, int>, std::less<char>, std::allocator<ft::Node<ft::pair<char, int> > > >::_root’ from ‘ft::Node<ft::pair<char, int> >’ to ‘bool’
   56 |    if (_root)
      |        ^~~~~
      |        |
      |        ft::Node<ft::pair<char, int> >
includes/avl_tree.h:57:15: error: cannot convert ‘ft::Node<ft::pair<char, int> >’ to ‘ft::Node<ft::pair<char, int> >*&’
   57 |     clear_all(_root);
      |               ^~~~~
      |               |
      |               ft::Node<ft::pair<char, int> >
includes/avl_tree.h:120:28: note:   initializing argument 1 of ‘void ft::tree<Pair, Compare, Alloc>::clear_all(ft::Node<T>*&) [with Pair = ft::pair<char, int>; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, int> > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<char, int> >*]’
  120 |   void clear_all(node_ptr &tmp)
      |                  ~~~~~~~~~~^~~
includes/avl_tree.h:58:26: error: cannot convert ‘ft::Node<ft::pair<char, int> >’ to ‘ft::tree<ft::pair<char, int>, std::less<char>, std::allocator<ft::Node<ft::pair<char, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, int> >*’}
   58 |    _root = _destroy_node(_root);
      |                          ^~~~~
      |                          |
      |                          ft::Node<ft::pair<char, int> >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<char, int>; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, int> > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<char, int> >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
includes/avl_tree.h:59:18: error: cannot convert ‘ft::Node<ft::pair<char, int> >’ to ‘ft::tree<ft::pair<char, int>, std::less<char>, std::allocator<ft::Node<ft::pair<char, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<char, int> >*’}
   59 |    _destroy_node(_real_end);
      |                  ^~~~~~~~~
      |                  |
      |                  ft::Node<ft::pair<char, int> >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<char, int>; Compare = std::less<char>; Alloc = std::allocator<ft::Node<ft::pair<char, int> > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<char, int> >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>::const_bidirectional_iterator(const ft::const_bidirectional_iterator<T>&) [with T = ft::pair<char, int>]’:
srcs/mainft.cpp:80:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<char, int>]’
srcs/mainft.cpp:195:14:   required from here
includes/const_bidirectional_iterator.h:31:9: error: lvalue required as left operand of assignment
   31 |    this = copy;
      |    ~~~~~^~~~~~
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>& ft::const_bidirectional_iterator<T>::operator++() [with T = ft::pair<char, int>]’:
srcs/mainft.cpp:82:21:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<char, int>]’
srcs/mainft.cpp:195:14:   required from here
includes/const_bidirectional_iterator.h:106:7: error: no matching function for call to ‘ft::Node<ft::pair<char, int> >::next()’
  106 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<char, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>::bidirectional_iterator(const ft::bidirectional_iterator<T>&) [with T = ft::pair<char, int>]’:
includes/bidirectional_iterator.h:108:26:   required from ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<char, int>]’
srcs/mainft.cpp:203:5:   required from here
includes/bidirectional_iterator.h:37:9: error: lvalue required as left operand of assignment
   37 |    this = copy;
      |    ~~~~~^~~~~~
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h: In instantiation of ‘ft::Node<Pair>* ft::Node<Pair>::prev() [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >]’:
includes/bidirectional_iterator.h:116:7:   required from ‘ft::bidirectional_iterator<T>& ft::bidirectional_iterator<T>::operator--() [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’
srcs/mainft.cpp:251:24:   required from here
includes/Node.h:95:14: error: ‘class ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ has no member named ‘left’; did you mean ‘_left’?
   95 |     if (tmp->left != NULL)
      |         ~~~~~^~~~
      |         _left
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘bool ft::bidirectional_iterator<T>::operator==(const ft::bidirectional_iterator<T>&) const [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’:
includes/map.h:320:10:   required from ‘ft::map<Key, T, Compare, Alloc>::mapped_type& ft::map<Key, T, Compare, Alloc>::operator[](const key_type&) [with Key = int; T = std::__cxx11::basic_string<char>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::mapped_type = std::__cxx11::basic_string<char>; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:257:7:   required from here
includes/bidirectional_iterator.h:75:17: error: ‘class ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ has no member named ‘value’; did you mean ‘_value’?
   75 |   return (&_it->value == rhs.operator->());
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘T& ft::bidirectional_iterator<T>::operator*() const [with T = ft::pair<int, std::__cxx11::basic_string<char> >; ft::bidirectional_iterator<T>::reference = ft::pair<int, std::__cxx11::basic_string<char> >&]’:
includes/map.h:320:37:   required from ‘ft::map<Key, T, Compare, Alloc>::mapped_type& ft::map<Key, T, Compare, Alloc>::operator[](const key_type&) [with Key = int; T = std::__cxx11::basic_string<char>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::mapped_type = std::__cxx11::basic_string<char>; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:257:7:   required from here
includes/bidirectional_iterator.h:89:16: error: ‘class ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ has no member named ‘value’; did you mean ‘_value’?
   89 |   return (_it->value);
      |          ~~~~~~^~~~~~
      |          _value
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::tree(const compare_type&, const allocator_type&) [with Pair = ft::pair<int, int>; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, int> > >; ft::tree<Pair, Compare, Alloc>::compare_type = std::less<int>; ft::tree<Pair, Compare, Alloc>::allocator_type = std::allocator<ft::Node<ft::pair<int, int> > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const int, int> >; Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, int> >]’
srcs/mainft.cpp:297:57:   required from here
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<int, int> >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<int, int>; ft::Node<Pair>::value_type = ft::pair<int, int>]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<int, int>&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<int, int>]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, int> >::Node(const ft::Node<ft::pair<int, int> >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<int, int> >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<int, int> >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<int, int>; ft::Node<Pair>::value_type = ft::pair<int, int>]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<int, int>&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<int, int>]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, int> >::Node(const ft::Node<ft::pair<int, int> >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<int, int> >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:48:14: error: no match for ‘operator=’ (operand types are ‘ft::Node<ft::pair<int, int> >’ and ‘ft::tree<ft::pair<int, int>, std::less<int>, std::allocator<ft::Node<ft::pair<int, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, int> >*’})
   48 |    _real_end = new_node(ft::pair<key_type, val_type>());
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, int> >& ft::Node<ft::pair<int, int> >::operator=(const ft::Node<ft::pair<int, int> >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘ft::tree<ft::pair<int, int>, std::less<int>, std::allocator<ft::Node<ft::pair<int, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, int> >*’} to ‘const ft::Node<ft::pair<int, int> >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:50:4: error: base operand of ‘->’ has non-pointer type ‘ft::Node<ft::pair<int, int> >’
   50 |    _real_end->print = 0;
      |    ^~~~~~~~~
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::~tree() [with Pair = ft::pair<int, int>; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, int> > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const int, int> >; Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, int> >]’
srcs/mainft.cpp:297:57:   required from here
includes/avl_tree.h:56:8: error: could not convert ‘((ft::tree<ft::pair<int, int>, std::less<int>, std::allocator<ft::Node<ft::pair<int, int> > > >*)this)->ft::tree<ft::pair<int, int>, std::less<int>, std::allocator<ft::Node<ft::pair<int, int> > > >::_root’ from ‘ft::Node<ft::pair<int, int> >’ to ‘bool’
   56 |    if (_root)
      |        ^~~~~
      |        |
      |        ft::Node<ft::pair<int, int> >
includes/avl_tree.h:57:15: error: cannot convert ‘ft::Node<ft::pair<int, int> >’ to ‘ft::Node<ft::pair<int, int> >*&’
   57 |     clear_all(_root);
      |               ^~~~~
      |               |
      |               ft::Node<ft::pair<int, int> >
includes/avl_tree.h:120:28: note:   initializing argument 1 of ‘void ft::tree<Pair, Compare, Alloc>::clear_all(ft::Node<T>*&) [with Pair = ft::pair<int, int>; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, int> > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, int> >*]’
  120 |   void clear_all(node_ptr &tmp)
      |                  ~~~~~~~~~~^~~
includes/avl_tree.h:58:26: error: cannot convert ‘ft::Node<ft::pair<int, int> >’ to ‘ft::tree<ft::pair<int, int>, std::less<int>, std::allocator<ft::Node<ft::pair<int, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, int> >*’}
   58 |    _root = _destroy_node(_root);
      |                          ^~~~~
      |                          |
      |                          ft::Node<ft::pair<int, int> >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<int, int>; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, int> > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, int> >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
includes/avl_tree.h:59:18: error: cannot convert ‘ft::Node<ft::pair<int, int> >’ to ‘ft::tree<ft::pair<int, int>, std::less<int>, std::allocator<ft::Node<ft::pair<int, int> > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, int> >*’}
   59 |    _destroy_node(_real_end);
      |                  ^~~~~~~~~
      |                  |
      |                  ft::Node<ft::pair<int, int> >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<int, int>; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, int> > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, int> >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h: In instantiation of ‘ft::Node<Pair>* ft::Node<Pair>::prev() [with Pair = ft::pair<int, int>]’:
includes/bidirectional_iterator.h:116:7:   required from ‘ft::bidirectional_iterator<T>& ft::bidirectional_iterator<T>::operator--() [with T = ft::pair<int, int>]’
srcs/mainft.cpp:301:50:   required from here
includes/Node.h:95:14: error: ‘class ft::Node<ft::pair<int, int> >’ has no member named ‘left’; did you mean ‘_left’?
   95 |     if (tmp->left != NULL)
      |         ~~~~~^~~~
      |         _left
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>::const_bidirectional_iterator(const ft::const_bidirectional_iterator<T>&) [with T = ft::pair<int, int>]’:
includes/map.h:70:4:   required from ‘ft::map<Key, T, Compare, Alloc>::map(const ft::map<Key, T, Compare, Alloc>&) [with Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >]’
srcs/mainft.cpp:306:42:   required from here
includes/const_bidirectional_iterator.h:31:9: error: lvalue required as left operand of assignment
   31 |    this = copy;
      |    ~~~~~^~~~~~
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>& ft::const_bidirectional_iterator<T>::operator++() [with T = ft::pair<int, int>]’:
srcs/mainft.cpp:82:21:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, int>]’
srcs/mainft.cpp:311:14:   required from here
includes/const_bidirectional_iterator.h:106:7: error: no matching function for call to ‘ft::Node<ft::pair<int, int> >::next()’
  106 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::tree(const compare_type&, const allocator_type&) [with Pair = ft::pair<int, foo<int> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, foo<int> > > >; ft::tree<Pair, Compare, Alloc>::compare_type = std::less<int>; ft::tree<Pair, Compare, Alloc>::allocator_type = std::allocator<ft::Node<ft::pair<int, foo<int> > > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const int, foo<int> > >; Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, foo<int> > >]’
srcs/mainft.cpp:372:58:   required from here
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<int, foo<int> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<int, foo<int> >; ft::Node<Pair>::value_type = ft::pair<int, foo<int> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<int, foo<int> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<int, foo<int> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, foo<int> > >::Node(const ft::Node<ft::pair<int, foo<int> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<int, foo<int> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<int, foo<int> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<int, foo<int> >; ft::Node<Pair>::value_type = ft::pair<int, foo<int> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<int, foo<int> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<int, foo<int> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, foo<int> > >::Node(const ft::Node<ft::pair<int, foo<int> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<int, foo<int> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:48:14: error: no match for ‘operator=’ (operand types are ‘ft::Node<ft::pair<int, foo<int> > >’ and ‘ft::tree<ft::pair<int, foo<int> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, foo<int> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, foo<int> > >*’})
   48 |    _real_end = new_node(ft::pair<key_type, val_type>());
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<int, foo<int> > >& ft::Node<ft::pair<int, foo<int> > >::operator=(const ft::Node<ft::pair<int, foo<int> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘ft::tree<ft::pair<int, foo<int> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, foo<int> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, foo<int> > >*’} to ‘const ft::Node<ft::pair<int, foo<int> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:50:4: error: base operand of ‘->’ has non-pointer type ‘ft::Node<ft::pair<int, foo<int> > >’
   50 |    _real_end->print = 0;
      |    ^~~~~~~~~
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::~tree() [with Pair = ft::pair<int, foo<int> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, foo<int> > > >]’:
includes/map.h:63:164:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = std::_List_iterator<ft::pair<const int, foo<int> > >; Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, foo<int> > >]’
srcs/mainft.cpp:372:58:   required from here
includes/avl_tree.h:56:8: error: could not convert ‘((ft::tree<ft::pair<int, foo<int> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, foo<int> > > > >*)this)->ft::tree<ft::pair<int, foo<int> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, foo<int> > > > >::_root’ from ‘ft::Node<ft::pair<int, foo<int> > >’ to ‘bool’
   56 |    if (_root)
      |        ^~~~~
      |        |
      |        ft::Node<ft::pair<int, foo<int> > >
includes/avl_tree.h:57:15: error: cannot convert ‘ft::Node<ft::pair<int, foo<int> > >’ to ‘ft::Node<ft::pair<int, foo<int> > >*&’
   57 |     clear_all(_root);
      |               ^~~~~
      |               |
      |               ft::Node<ft::pair<int, foo<int> > >
includes/avl_tree.h:120:28: note:   initializing argument 1 of ‘void ft::tree<Pair, Compare, Alloc>::clear_all(ft::Node<T>*&) [with Pair = ft::pair<int, foo<int> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, foo<int> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, foo<int> > >*]’
  120 |   void clear_all(node_ptr &tmp)
      |                  ~~~~~~~~~~^~~
includes/avl_tree.h:58:26: error: cannot convert ‘ft::Node<ft::pair<int, foo<int> > >’ to ‘ft::tree<ft::pair<int, foo<int> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, foo<int> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, foo<int> > >*’}
   58 |    _root = _destroy_node(_root);
      |                          ^~~~~
      |                          |
      |                          ft::Node<ft::pair<int, foo<int> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<int, foo<int> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, foo<int> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, foo<int> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
includes/avl_tree.h:59:18: error: cannot convert ‘ft::Node<ft::pair<int, foo<int> > >’ to ‘ft::tree<ft::pair<int, foo<int> >, std::less<int>, std::allocator<ft::Node<ft::pair<int, foo<int> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<int, foo<int> > >*’}
   59 |    _destroy_node(_real_end);
      |                  ^~~~~~~~~
      |                  |
      |                  ft::Node<ft::pair<int, foo<int> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<int, foo<int> >; Compare = std::less<int>; Alloc = std::allocator<ft::Node<ft::pair<int, foo<int> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<int, foo<int> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>::const_bidirectional_iterator(const ft::const_bidirectional_iterator<T>&) [with T = ft::pair<int, foo<int> >]’:
srcs/mainft.cpp:80:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:373:14:   required from here
includes/const_bidirectional_iterator.h:31:9: error: lvalue required as left operand of assignment
   31 |    this = copy;
      |    ~~~~~^~~~~~
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T>& ft::const_bidirectional_iterator<T>::operator++() [with T = ft::pair<int, foo<int> >]’:
srcs/mainft.cpp:82:21:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:373:14:   required from here
includes/const_bidirectional_iterator.h:106:7: error: no matching function for call to ‘ft::Node<ft::pair<int, foo<int> > >::next()’
  106 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, foo<int> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘bool ft::const_bidirectional_iterator<T>::operator==(const ft::const_bidirectional_iterator<T>&) const [with T = ft::pair<int, foo<int> >]’:
srcs/mainft.cpp:361:41:   required from ‘void ft_const_bound(const MAP&, const int&) [with MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:374:24:   required from here
includes/const_bidirectional_iterator.h:80:17: error: ‘class ft::Node<ft::pair<int, foo<int> > >’ has no member named ‘value’; did you mean ‘_value’?
   80 |   return (&_it->value == rhs.operator->());
      |            ~~~~~^~~~~
      |            _value
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>::bidirectional_iterator(const ft::bidirectional_iterator<T>&) [with T = ft::pair<int, foo<int> >]’:
includes/map.h:175:13:   required from ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::lower_bound(const key_type&) [with Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::iterator = ft::bidirectional_iterator<ft::pair<int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:382:18:   required from here
includes/bidirectional_iterator.h:37:9: error: lvalue required as left operand of assignment
   37 |    this = copy;
      |    ~~~~~^~~~~~
includes/bidirectional_iterator.h: In instantiation of ‘T& ft::bidirectional_iterator<T>::operator*() const [with T = ft::pair<int, foo<int> >; ft::bidirectional_iterator<T>::reference = ft::pair<int, foo<int> >&]’:
includes/map.h:180:15:   required from ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::lower_bound(const key_type&) [with Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::iterator = ft::bidirectional_iterator<ft::pair<int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:382:18:   required from here
includes/bidirectional_iterator.h:89:16: error: ‘class ft::Node<ft::pair<int, foo<int> > >’ has no member named ‘value’; did you mean ‘_value’?
   89 |   return (_it->value);
      |          ~~~~~~^~~~~~
      |          _value
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<int, foo<int> >]’:
includes/map.h:182:8:   required from ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::lower_bound(const key_type&) [with Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::iterator = ft::bidirectional_iterator<ft::pair<int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:382:18:   required from here
includes/bidirectional_iterator.h:109:7: error: no matching function for call to ‘ft::Node<ft::pair<int, foo<int> > >::next()’
  109 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, foo<int> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘bool ft::bidirectional_iterator<T>::operator==(const ft::bidirectional_iterator<T>&) const [with T = ft::pair<int, foo<int> >]’:
srcs/mainft.cpp:343:41:   required from ‘void ft_bound(MAP&, const int&) [with MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:384:16:   required from here
includes/bidirectional_iterator.h:75:17: error: ‘class ft::Node<ft::pair<int, foo<int> > >’ has no member named ‘value’; did you mean ‘_value’?
   75 |   return (&_it->value == rhs.operator->());
      |            ~~~~~^~~~~
      |            _value
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::tree(const compare_type&, const allocator_type&) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::compare_type = std::less<std::__cxx11::basic_string<char> >; ft::tree<Pair, Compare, Alloc>::allocator_type = std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > >]’:
includes/map.h:57:131:   required from ‘ft::map<Key, T, Compare, Alloc>::map(const key_compare&, const allocator_type&) [with Key = std::__cxx11::basic_string<char>; T = std::__cxx11::basic_string<char>; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<std::__cxx11::basic_string<char> >; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:405:32:   required from here
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; ft::Node<Pair>::value_type = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::Node(const ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:46:178: error: no matching function for call to ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::Node(NULL)’
   46 |   tree(const compare_type &comp = compare_type(), const allocator_type &alloc = allocator_type()) : _alloc(alloc), _compare(comp), _root(NULL), _size(0), _real_end(), _maxi(NULL)
      |                                                                                                                                                                                  ^
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:39:4: note: candidate: ‘ft::Node<Pair>::Node(const value_type&) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; ft::Node<Pair>::value_type = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’
   39 |    Node (const value_type &value)
      |    ^~~~
includes/Node.h:39:28: note:   no known conversion for argument 1 from ‘long int’ to ‘const value_type&’ {aka ‘const ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >&’}
   39 |    Node (const value_type &value)
      |          ~~~~~~~~~~~~~~~~~~^~~~~
includes/Node.h:27:4: note: candidate: ‘ft::Node<Pair>::Node() [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’
   27 |    Node ()
      |    ^~~~
includes/Node.h:27:4: note:   candidate expects 0 arguments, 1 provided
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::Node(const ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘long int’ to ‘const ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:48:14: error: no match for ‘operator=’ (operand types are ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’ and ‘ft::tree<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*’})
   48 |    _real_end = new_node(ft::pair<key_type, val_type>());
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:8:9: note: candidate: ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >& ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::operator=(const ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >&)’
    8 |   class Node
      |         ^~~~
includes/Node.h:8:9: note:   no known conversion for argument 1 from ‘ft::tree<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*’} to ‘const ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >&’
In file included from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/avl_tree.h:50:4: error: base operand of ‘->’ has non-pointer type ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’
   50 |    _real_end->print = 0;
      |    ^~~~~~~~~
includes/avl_tree.h: In instantiation of ‘ft::tree<Pair, Compare, Alloc>::~tree() [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > >]’:
includes/map.h:57:131:   required from ‘ft::map<Key, T, Compare, Alloc>::map(const key_compare&, const allocator_type&) [with Key = std::__cxx11::basic_string<char>; T = std::__cxx11::basic_string<char>; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<std::__cxx11::basic_string<char> >; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:405:32:   required from here
includes/avl_tree.h:56:8: error: could not convert ‘((ft::tree<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > > >*)this)->ft::tree<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > > >::_root’ from ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’ to ‘bool’
   56 |    if (_root)
      |        ^~~~~
      |        |
      |        ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:57:15: error: cannot convert ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’ to ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*&’
   57 |     clear_all(_root);
      |               ^~~~~
      |               |
      |               ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:120:28: note:   initializing argument 1 of ‘void ft::tree<Pair, Compare, Alloc>::clear_all(ft::Node<T>*&) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*]’
  120 |   void clear_all(node_ptr &tmp)
      |                  ~~~~~~~~~~^~~
includes/avl_tree.h:58:26: error: cannot convert ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’ to ‘ft::tree<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*’}
   58 |    _root = _destroy_node(_root);
      |                          ^~~~~
      |                          |
      |                          ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
includes/avl_tree.h:59:18: error: cannot convert ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’ to ‘ft::tree<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >, std::less<std::__cxx11::basic_string<char> >, std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > > >::node_ptr’ {aka ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*’}
   59 |    _destroy_node(_real_end);
      |                  ^~~~~~~~~
      |                  |
      |                  ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >
includes/avl_tree.h:141:35: note:   initializing argument 1 of ‘ft::Node<T>* ft::tree<Pair, Compare, Alloc>::_destroy_node(ft::tree<Pair, Compare, Alloc>::node_ptr) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > > >; ft::tree<Pair, Compare, Alloc>::node_ptr = ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >*]’
  141 |   node_ptr _destroy_node(node_ptr node)
      |                          ~~~~~~~~~^~~~
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T>& ft::bidirectional_iterator<T>::operator++() [with T = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’:
srcs/mainft.cpp:397:27:   required from ‘void print_map(It, It) [with It = ft::bidirectional_iterator<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:423:30:   required from here
includes/bidirectional_iterator.h:101:7: error: no matching function for call to ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::next()’
  101 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘T* ft::bidirectional_iterator<T>::operator->() const [with T = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >; ft::bidirectional_iterator<T>::pointer = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >*]’:
srcs/mainft.cpp:398:31:   required from ‘void print_map(It, It) [with It = ft::bidirectional_iterator<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:423:30:   required from here
includes/bidirectional_iterator.h:95:17: error: ‘class ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >’ has no member named ‘value’; did you mean ‘_value’?
   95 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<char, foo<float> >]’:
includes/map.h:182:8:   required from ‘ft::map<Key, T, Compare, Alloc>::iterator ft::map<Key, T, Compare, Alloc>::lower_bound(const key_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::iterator = ft::bidirectional_iterator<ft::pair<char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::key_type = char]’
includes/map.h:319:13:   required from ‘ft::map<Key, T, Compare, Alloc>::mapped_type& ft::map<Key, T, Compare, Alloc>::operator[](const key_type&) [with Key = char; T = foo<float>; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, foo<float> > >; ft::map<Key, T, Compare, Alloc>::mapped_type = foo<float>; ft::map<Key, T, Compare, Alloc>::key_type = char]’
srcs/mainft.cpp:127:8:   required from here
includes/bidirectional_iterator.h:109:7: error: no matching function for call to ‘ft::Node<ft::pair<char, foo<float> > >::next()’
  109 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<char, foo<float> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘T* ft::const_bidirectional_iterator<T>::operator->() const [with T = ft::pair<int, std::__cxx11::basic_string<char> >; ft::const_bidirectional_iterator<T>::pointer = ft::pair<int, std::__cxx11::basic_string<char> >*]’:
srcs/mainft.cpp:67:18:   required from ‘std::string printPair(const T&, bool, std::ostream&) [with T = ft::const_bidirectional_iterator<ft::pair<int, std::__cxx11::basic_string<char> > >; std::string = std::__cxx11::basic_string<char>; std::ostream = std::basic_ostream<char>]’
srcs/mainft.cpp:83:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, std::__cxx11::basic_string<char> >]’
srcs/mainft.cpp:168:14:   required from here
includes/const_bidirectional_iterator.h:100:17: error: ‘class ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >’ has no member named ‘value’; did you mean ‘_value’?
  100 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/const_bidirectional_iterator.h: In instantiation of ‘T* ft::const_bidirectional_iterator<T>::operator->() const [with T = ft::pair<char, int>; ft::const_bidirectional_iterator<T>::pointer = ft::pair<char, int>*]’:
srcs/mainft.cpp:67:18:   required from ‘std::string printPair(const T&, bool, std::ostream&) [with T = ft::const_bidirectional_iterator<ft::pair<char, int> >; std::string = std::__cxx11::basic_string<char>; std::ostream = std::basic_ostream<char>]’
srcs/mainft.cpp:83:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<char, int>]’
srcs/mainft.cpp:195:14:   required from here
includes/const_bidirectional_iterator.h:100:17: error: ‘class ft::Node<ft::pair<char, int> >’ has no member named ‘value’; did you mean ‘_value’?
  100 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T> ft::const_bidirectional_iterator<T>::operator++(int) [with T = ft::pair<char, int>]’:
includes/map.h:108:8:   required from ‘void ft::map<Key, T, Compare, Alloc>::insert(InputIterator, InputIterator, typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type*) [with InputIterator = ft::const_bidirectional_iterator<ft::pair<char, int> >; Key = char; T = int; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, int> >; typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type = ft::const_bidirectional_iterator<ft::pair<char, int> >]’
includes/map.h:312:4:   required from ‘ft::map<Key, T, Compare, Alloc>& ft::map<Key, T, Compare, Alloc>::operator=(const ft::map<Key, T, Compare, Alloc>&) [with Key = char; T = int; Compare = std::less<char>; Alloc = std::allocator<ft::pair<const char, int> >]’
srcs/mainft.cpp:198:8:   required from here
includes/const_bidirectional_iterator.h:114:7: error: no matching function for call to ‘ft::Node<ft::pair<char, int> >::next()’
  114 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<char, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<int, std::__cxx11::basic_string<char> >]’:
includes/map.h:140:10:   required from ‘void ft::map<Key, T, Compare, Alloc>::erase(ft::map<Key, T, Compare, Alloc>::iterator, ft::map<Key, T, Compare, Alloc>::iterator) [with Key = int; T = std::__cxx11::basic_string<char>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::iterator = ft::bidirectional_iterator<ft::pair<int, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:235:2:   required from ‘void ft_erase(MAP&, U, V) [with MAP = ft::map<int, std::__cxx11::basic_string<char> >; U = ft::bidirectional_iterator<ft::pair<int, std::__cxx11::basic_string<char> > >; V = ft::bidirectional_iterator<ft::pair<int, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:253:47:   required from here
includes/bidirectional_iterator.h:109:7: error: no matching function for call to ‘ft::Node<ft::pair<int, std::__cxx11::basic_string<char> > >::next()’
  109 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, std::__cxx11::basic_string<char> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<int, int>]’:
includes/map.h:108:8:   required from ‘void ft::map<Key, T, Compare, Alloc>::insert(InputIterator, InputIterator, typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type*) [with InputIterator = ft::bidirectional_iterator<ft::pair<int, int> >; Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >; typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type = ft::bidirectional_iterator<ft::pair<int, int> >]’
includes/map.h:65:4:   required from ‘ft::map<Key, T, Compare, Alloc>::map(InputIterator, InputIterator, const key_compare&, const allocator_type&) [with InputIterator = ft::bidirectional_iterator<ft::pair<int, int> >; Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >; ft::map<Key, T, Compare, Alloc>::key_compare = std::less<int>; ft::map<Key, T, Compare, Alloc>::allocator_type = std::allocator<ft::pair<const int, int> >]’
srcs/mainft.cpp:301:54:   required from here
includes/bidirectional_iterator.h:109:7: error: no matching function for call to ‘ft::Node<ft::pair<int, int> >::next()’
  109 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T> ft::const_bidirectional_iterator<T>::operator++(int) [with T = ft::pair<int, int>]’:
includes/map.h:108:8:   required from ‘void ft::map<Key, T, Compare, Alloc>::insert(InputIterator, InputIterator, typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type*) [with InputIterator = ft::const_bidirectional_iterator<ft::pair<int, int> >; Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >; typename ft::enable_if<(! ft::is_integral<InputIterator>::value), InputIterator>::type = ft::const_bidirectional_iterator<ft::pair<int, int> >]’
includes/map.h:70:4:   required from ‘ft::map<Key, T, Compare, Alloc>::map(const ft::map<Key, T, Compare, Alloc>&) [with Key = int; T = int; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, int> >]’
srcs/mainft.cpp:306:42:   required from here
includes/const_bidirectional_iterator.h:114:7: error: no matching function for call to ‘ft::Node<ft::pair<int, int> >::next()’
  114 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, int>]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:13,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/const_bidirectional_iterator.h: In instantiation of ‘T* ft::const_bidirectional_iterator<T>::operator->() const [with T = ft::pair<int, int>; ft::const_bidirectional_iterator<T>::pointer = ft::pair<int, int>*]’:
srcs/mainft.cpp:67:18:   required from ‘std::string printPair(const T&, bool, std::ostream&) [with T = ft::const_bidirectional_iterator<ft::pair<int, int> >; std::string = std::__cxx11::basic_string<char>; std::ostream = std::basic_ostream<char>]’
srcs/mainft.cpp:83:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, int>]’
srcs/mainft.cpp:311:14:   required from here
includes/const_bidirectional_iterator.h:100:17: error: ‘class ft::Node<ft::pair<int, int> >’ has no member named ‘value’; did you mean ‘_value’?
  100 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/const_bidirectional_iterator.h: In instantiation of ‘T* ft::const_bidirectional_iterator<T>::operator->() const [with T = ft::pair<int, foo<int> >; ft::const_bidirectional_iterator<T>::pointer = ft::pair<int, foo<int> >*]’:
srcs/mainft.cpp:67:18:   required from ‘std::string printPair(const T&, bool, std::ostream&) [with T = ft::const_bidirectional_iterator<ft::pair<int, foo<int> > >; std::string = std::__cxx11::basic_string<char>; std::ostream = std::basic_ostream<char>]’
srcs/mainft.cpp:83:34:   required from ‘void printSize(const T_MAP&, bool) [with T_MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:373:14:   required from here
includes/const_bidirectional_iterator.h:100:17: error: ‘class ft::Node<ft::pair<int, foo<int> > >’ has no member named ‘value’; did you mean ‘_value’?
  100 |   return (&_it->value);
      |            ~~~~~^~~~~
      |            _value
includes/const_bidirectional_iterator.h: In instantiation of ‘T& ft::const_bidirectional_iterator<T>::operator*() const [with T = ft::pair<int, foo<int> >; ft::const_bidirectional_iterator<T>::reference = ft::pair<int, foo<int> >&]’:
includes/map.h:195:15:   required from ‘ft::map<Key, T, Compare, Alloc>::const_iterator ft::map<Key, T, Compare, Alloc>::lower_bound(const key_type&) const [with Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::const_iterator = ft::const_bidirectional_iterator<ft::pair<int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:359:8:   required from ‘void ft_const_bound(const MAP&, const int&) [with MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:374:24:   required from here
includes/const_bidirectional_iterator.h:94:16: error: ‘class ft::Node<ft::pair<int, foo<int> > >’ has no member named ‘value’; did you mean ‘_value’?
   94 |   return (_it->value);
      |          ~~~~~~^~~~~~
      |          _value
includes/const_bidirectional_iterator.h: In instantiation of ‘ft::const_bidirectional_iterator<T> ft::const_bidirectional_iterator<T>::operator++(int) [with T = ft::pair<int, foo<int> >]’:
includes/map.h:197:8:   required from ‘ft::map<Key, T, Compare, Alloc>::const_iterator ft::map<Key, T, Compare, Alloc>::lower_bound(const key_type&) const [with Key = int; T = foo<int>; Compare = std::less<int>; Alloc = std::allocator<ft::pair<const int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::const_iterator = ft::const_bidirectional_iterator<ft::pair<int, foo<int> > >; ft::map<Key, T, Compare, Alloc>::key_type = int]’
srcs/mainft.cpp:359:8:   required from ‘void ft_const_bound(const MAP&, const int&) [with MAP = ft::map<int, foo<int> >]’
srcs/mainft.cpp:374:24:   required from here
includes/const_bidirectional_iterator.h:114:7: error: no matching function for call to ‘ft::Node<ft::pair<int, foo<int> > >::next()’
  114 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<int, foo<int> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
In file included from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/bidirectional_iterator.h: In instantiation of ‘ft::bidirectional_iterator<T> ft::bidirectional_iterator<T>::operator++(int) [with T = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’:
includes/map.h:140:10:   required from ‘void ft::map<Key, T, Compare, Alloc>::erase(ft::map<Key, T, Compare, Alloc>::iterator, ft::map<Key, T, Compare, Alloc>::iterator) [with Key = std::__cxx11::basic_string<char>; T = std::__cxx11::basic_string<char>; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >; ft::map<Key, T, Compare, Alloc>::iterator = ft::bidirectional_iterator<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
includes/map.h:148:4:   required from ‘void ft::map<Key, T, Compare, Alloc>::clear() [with Key = std::__cxx11::basic_string<char>; T = std::__cxx11::basic_string<char>; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
includes/map.h:75:4:   required from ‘ft::map<Key, T, Compare, Alloc>::~map() [with Key = std::__cxx11::basic_string<char>; T = std::__cxx11::basic_string<char>; Compare = std::less<std::__cxx11::basic_string<char> >; Alloc = std::allocator<ft::pair<const std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >]’
srcs/mainft.cpp:405:32:   required from here
includes/bidirectional_iterator.h:109:7: error: no matching function for call to ‘ft::Node<ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> > >::next()’
  109 |   _it = _it->next();
In file included from includes/bidirectional_iterator.h:3,
                 from includes/avl_tree.h:12,
                 from includes/map.h:3,
                 from srcs/mainft.cpp:3:
includes/Node.h:73:10: note: candidate: ‘ft::Node<Pair>* ft::Node<Pair>::next(ft::Node<Pair>*) [with Pair = ft::pair<std::__cxx11::basic_string<char>, std::__cxx11::basic_string<char> >]’
   73 |    Node *next(Node *search)
      |          ^~~~
includes/Node.h:73:10: note:   candidate expects 1 argument, 0 provided
make[1]: *** [Makefile:34: objs/mainft.o] Error 1
make: *** [Makefile:31: all] Error 2
